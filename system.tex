\section{The System\label{sec:system}}

% High-level architecture

The internal computing infrastructure of organizations has changed
radically in the last fifteen years. The shift from large
servers toward scalable, lower-cost, distributed systems (``the cloud'')
led to a software ecosystem of processes distributed over a
network (often virtually defined) communicating via some
high-level protocol, usually HTTP. HTTP is dominant because web
browsers and servers are ubiquitous and available in almost
all hardware devices, from tiny sensors, to handheld devices and
laptops, to rack-mounted servers.

As a result, HTTP is the lingua franca of interprocess communication
(IPC). One of the design goals for RCloud was to provide a productive
environment for creators of data-analysis scripts, that also behaves
as a first-class citizen in the pre-existing ecosystem of computer
services and networks in an organization.

%% Design for cloud-friendly? This goes back to the point in the
%% introduction about playing nice with the rest of the ecosystem.

\subsection{System Design}

We designed RCloud around the front-facing API, which provides roughly
one entry point to correspond with each requirement.

The central of the screen is for editing code and visualizations through
the notebook interface. Supplementary ``asset'' files which are part of the
notebook but not part of the notebook flow, are edited on the right.
Controls at the top of the screen allow the user to quickly run, view, 
and share the notebook. The call mechanism is the URL itself; arguments are
read from the URL and the final cell is the result. On the left are the 
browsing area for seeing other users' notebooks and for searching, as well
as the help system.

\subsection{Notebooks\label{sec:notebooks}}

The basic unit of operation in RCloud is a \emph{notebook}. A notebook
holds a sequence of \emph{cells}, each of which represents a
snippet of code or hypertext in Markdown. This is not a novel idea;
executable documents structured in this way are present in a wide
variety of other software systems, including Mathematica, IPython and Sage.

One of the main differences between RCloud and other systems is the
notion that notebooks are ``always deployed''. This improves the
ability to share and modify experiments and compose the results
without binding to specific versions of a notebook.
On the other hand, there are a variety of situations where it might
be necessary to name a specific version. Rather than force notebook
designers to decide which versions need to be preserved,
we embrace \emph{transparent} versioning.
This is similar to models like Jankun-Kelly et al.'s p-set calculus \cite{Jankun-Kelly:2007:MFV}
and VisTrails's version tree \cite{Callahan:2006:VVM}, where every change in the state of the system is tracked.

Implementing an entire version-control subsystem from scratch would
be a large undertaking. Fortunately, we can build RCloud on top of Github's
\emph{gists}~\cite{Github:2014:GG}. Github offers a HTTP interface
for creating simplified git repositories (the main limitation being the
use of text-only files in a single directory). The GitHub web-service
API provides most of the semantics we need for the versioning
portion of the storage back end: access to previous versions,
comments, starring, and forking.

Using GitHub was mainly a tactical decision to reduce our
time-to-prototype. At the same time, it had the beneficial effect of
allowing our backend to communicate with separate processes over HTTP
and JSON. This had the serendipitous advantage of quickly enabling
full search over RCloud notebooks, using Apache SOLR.
%
This perspective has implications for
systems-based research and prototyping in visual analytics:
For small teams to efficiently explore novel ideas toward the
improvement of a large, complex software ecosystem, it pays off
to use existing solutions as far as possible.
%
Even though it involved learning standards that are not directly
related to visual analytics, our early decision to use the GitHub
gist API was successful. Future projects can gain many
of the same benefits by adopting a similar strategy.

%% %
%% We needed version control over a directory, gist provides that,
%% wrapped over an HTTP interface.
%% %
%% Mainly a tactical decision to save time.
%% %
%% Nevertheless, availability of notebook data as (barely) plain text had good side
%% effects, like ease to build search.
%% %
%% Expect same with suggest.

\subsection{Reputation and Interest: starring\label{sec:starring}}

In RCloud, reputation and interest are a relationship between
\emph{notebooks} and \emph{users}, rather than a relationship between
user pairs. We decided on this approach because we expect typical
RCloud deployments to have relatively few users, but each user to have
written relatively many notebooks. Under that assumption, assigning
interest to users would not provide sufficiently ``high-resolution'' data.

We incorporate both explicit and implicit indications of interest
in notebooks. Explicit interest is signaled by ``starring,'' or
clicking on a button that marks a notebook as interesting.
This makes explicit indication of interest a nearly trivial operation,
always readily available, to encourage its use.

Implicit signaling of interest is supported by keeping click-through
\cite{Joachims:2005:AIC} and execution counts. (In addition to these
classic techniques of collecting feedback from web search, we anticipate
applying static and dynamic code analysis to generate fine-grained
information about relationships, for example, which packages and data
sets often appear together.)

\subsection{Executing R in a web browser}

One our main goals is to provide ubiquitous access to the statistical
tools of the R programming language in the wider environment in which data
science teams participate.
%
Given the recent developments of interactive visualization and visual
analytics in HTML5 and the web, we decided to create an
\emph{interconnect} between the two environments.
%
Every RCloud session spawns a new R execution process in a remote
server. The communication between the web browser and the 

%% \subsubsection{Object capabilities: R to Javascript RPC and access
%%   control}

HTTP and web services are convenient but much of the protocol is
stateless. (For example, GET requests are required to not change the
remote state, and results can be cached in transparent proxies along
the network). In the case of close communication between a running
R process and a web browser, we need something that is more flexible
than distinct URLs for every R process, and which embraces
statefulness of both calculations and insights in progress.


\subsection{Interactive notebooks\label{sec:notebooks}}

%% How do we do things that are not trivial to do with IPython (for
%% example)

%% What is relationship to a standard CMS with R/Python

%% dcplot. two-way communication between between backend session and
%% frontend session.

A key engineering decision in RCloud was to rely on full two-way
communication between the web client human interface, and data and
computing resources in the cloud. It is easier to engineer a design
in which the human interface is pushed one-way from the server
and thereafter all interaction takes place within the client.
Two-way communication is necessary, though, where the size of
the data or computational performance makes it impractical to
move all computation to the client.

In addition, R is well suited as a language for analysis, and
JavaScript for interactive visualization. To draw on
the strengths of both languages and both environments, the connection
between the languages is not just procedural: it makes \emph{closures}
and \emph{first-class functions} available across the network.
This provides considerable flexibility, so that for example, a chart built
with dc.js or leaflet.js can call back to analysis functions in R
without having to formalize the protocol between the processes.

\subsection{Deployment of notebooks\label{sec:deployment}}

Because notebooks are continually published, any work is immediately
available both as a subroutine and visual component. Close colleagues
can start on the next stage of analysis, or delve into the data,
even while the original author is polishing the algorithm or its
presentation. The code is the page, and can either be shaped into
a function of inputs and outputs, or the linear cells of the notebook
can be reworked into a full-fledged HTML layout.

Every notebook in RCloud is named by a URL, and notebooks by
default are visible by the entire organization. This is deliberate.
As pointed out by Wattenberg and Kriss~\cite{Wattenberg:2011:DFS},
broad access to analysis outputs (in their case, for NameVoyager)
increases long-term engagement in part through cross-references on
the web. Although our prototype RCloud deployment is only visible
inside a corporate intranet, we nevertheless found anecdotal support
for this notion by discovering links to RCloud notebooks in internal
discussion fora and mailing lists.
